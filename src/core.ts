import type { DotenvParseOutput } from "dotenv";
import { parse } from "dotenv";

const defaultPrefix = "/* Auto generated by typedotenv */";

type PropertyOptions = { patterns?: Record<string, string> } & (
	| { allowList: string[]; denyList?: undefined; required?: undefined }
	| { allowList?: undefined; denyList?: string[]; required?: string[] }
);
export type GenerateOptions = PropertyOptions & {
	/**
	 * Prefix for generated code.
	 * @default `/* Auto generated by typedotenv *‍/`
	 */
	prefix?: string;
	/**
	 * Object that provide environment variables
	 * @default `process.env`
	 * @example `import.meta.env`
	 */
	envObject?: string;
	/**
	 * Disable type assertions like `as string`
	 * @example
	 * disableTypeAssertion: true
	 * ```js
	 * export const VAR = process.env.VAR;
	 * ```
	 * disableTypeAssertion: false
	 * ```ts
	 * export const VAR = process.env.VAR as string;
	 * ```
	 */
	disableTypeAssertion?: boolean;
	/**
	 * End of line cheracter
	 * @default `\n`
	 */
	eol?: string;
};

export class ValidationError extends Error {}

/**
 * Validation keys or values
 * @param parsed Parsed dotenv
 * @param options Property options
 * @throws {ValidationError} If not allowed key or value found
 */
export const validation = (
	parsed: DotenvParseOutput,
	{ allowList, denyList, required, patterns }: PropertyOptions,
) => {
	if (allowList) {
		const notAllowed = Object.keys(parsed).filter(
			(key) => !allowList.includes(key),
		);
		if (notAllowed.length > 0)
			throw new ValidationError(
				`Not allowed key found: ${notAllowed.join(", ")}`,
			);
	}
	if (denyList) {
		const denied = denyList.filter((key) => typeof parsed[key] === "string");
		if (denied.length > 0)
			throw new ValidationError(`Denied key found: ${denied.join(", ")}`);
	}
	if (required) {
		const notIncluded = required.filter(
			(key) => typeof parsed[key] === "undefined",
		);
		if (notIncluded.length > 0)
			throw new ValidationError(
				`Required keys are not included: ${notIncluded.join(", ")}`,
			);
	}
	if (patterns) {
		const notMatched = Object.entries(patterns)
			.filter(([key, pattern]) => {
				const value = parsed[key];
				if (typeof value === "undefined") return false;
				return !value.match(new RegExp(pattern));
			})
			.map(([k]) => k);
		if (notMatched.length > 0)
			throw new ValidationError(`Not allowed pattern found: ${notMatched}`);
	}
};

export const generate = (dotenv: string, options: GenerateOptions = {}) => {
	const parsed = parse(dotenv);
	validation(parsed, options);
	const eol = options.eol ?? "\n";
	const envObject = options.envObject ?? "process.env";
	const typeAssertion = options.disableTypeAssertion ? "" : " as string";
	const definitions = Object.keys(parsed).map(
		(key) => `export const ${key} = ${envObject}.${key}${typeAssertion};`,
	);
	const code =
		[options.prefix ?? defaultPrefix, ...definitions].join(eol) + eol;
	return code;
};
